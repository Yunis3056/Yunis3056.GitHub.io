<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Java进阶 | YunisTo</title><meta name="author" content="知无涯"><meta name="copyright" content="知无涯"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="javaSE进阶学习异常处理在Java中，异常处理是一种机制，用于在程序运行过程中处理错误和异常情况。Java中的异常是指在程序运行时出现的一些错误，例如数组越界、空指针、类型转换等。Java提供了一套完整的异常处理机制，允许程序员捕获和处理异常，从而使程序更加健壮和可靠。 Java中的异常处理机制包括两个部分：异常抛出和异常捕获。当程序执行过程中出现异常时，会抛出一个异常对象，这个异常对象会被传">
<meta property="og:type" content="article">
<meta property="og:title" content="Java进阶">
<meta property="og:url" content="http://example.com/2023/03/29/java%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="YunisTo">
<meta property="og:description" content="javaSE进阶学习异常处理在Java中，异常处理是一种机制，用于在程序运行过程中处理错误和异常情况。Java中的异常是指在程序运行时出现的一些错误，例如数组越界、空指针、类型转换等。Java提供了一套完整的异常处理机制，允许程序员捕获和处理异常，从而使程序更加健壮和可靠。 Java中的异常处理机制包括两个部分：异常抛出和异常捕获。当程序执行过程中出现异常时，会抛出一个异常对象，这个异常对象会被传">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-03-29T04:20:16.000Z">
<meta property="article:modified_time" content="2023-04-21T10:48:39.844Z">
<meta property="article:author" content="知无涯">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/03/29/java%E8%BF%9B%E9%98%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java进阶',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-21 18:48:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Yunis3056/blogimage@main/img/08.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="YunisTo"><span class="site-name">YunisTo</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java进阶</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-29T04:20:16.000Z" title="发表于 2023-03-29 12:20:16">2023-03-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-21T10:48:39.844Z" title="更新于 2023-04-21 18:48:39">2023-04-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java进阶"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="javaSE进阶学习"><a href="#javaSE进阶学习" class="headerlink" title="javaSE进阶学习"></a>javaSE进阶学习</h1><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>在Java中，异常处理是一种机制，用于在程序运行过程中处理错误和异常情况。Java中的异常是指在程序运行时出现的一些错误，例如数组越界、空指针、类型转换等。Java提供了一套完整的异常处理机制，允许程序员捕获和处理异常，从而使程序更加健壮和可靠。</p>
<p>Java中的异常处理机制包括两个部分：异常抛出和异常捕获。当程序执行过程中出现异常时，会抛出一个异常对象，这个异常对象会被传递到调用栈中，直到有合适的异常处理机制来处理它。在Java中，可以使用try-catch语句来捕获异常并进行处理，语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 可能会抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType1 e1) &#123;</span><br><span class="line">  <span class="comment">// 处理ExceptionType1类型的异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType2 e2) &#123;</span><br><span class="line">  <span class="comment">// 处理ExceptionType2类型的异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// 不管有没有异常，都会执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中，try语句块中包含可能会抛出异常的代码，catch语句块用于捕获和处理异常，finally语句块中的代码不管有没有异常都会执行。catch语句块可以包含多个，用于处理不同类型的异常。</span></span><br></pre></td></tr></table></figure>

<p>Java中的异常分为两类：受检异常和非受检异常。受检异常是指在编译时就能够被发现的异常，例如IOException、SQLException等，必须在代码中进行捕获或者抛出。非受检异常是指在运行时才会发生的异常，例如NullPointerException、ArrayIndexOutOfBoundsException等，不需要在代码中进行捕获或者抛出，但可以在需要的时候进行处理。</p>
<p>除了try-catch语句外，Java还提供了一些其他的异常处理机制，例如throw语句、throws声明、自定义异常等。</p>
<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>String类代表字符串类型，是Java应用程序中最常用的基本数据类型之一。它可以存储任何类型的文本，包括字符、数字和符号等。</p>
<p><code>String</code>是Java编程语言中的一个类，用于表示字符串（即一系列字符）。</p>
<ul>
<li><h4 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h4><p>在Java中创建字符串可以有以下几种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接赋值创建</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用构造函数创建</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用字符数组创建</span></span><br><span class="line"><span class="type">char</span>[] chars = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;!&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用字节数组创建</span></span><br><span class="line"><span class="type">byte</span>[] bytes = &#123;<span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">32</span>, <span class="number">119</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">108</span>, <span class="number">100</span>, <span class="number">33</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h4><p><code>String</code>类提供了很多方法来处理字符串。下面是一些常用的方法：</p>
<ul>
<li><code>length()</code>: 返回字符串的长度。</li>
<li><code>charAt(index)</code>: 返回指定索引处的字符。</li>
<li><code>substring(beginIndex, endIndex)</code>: 返回从<code>beginIndex</code>开始到<code>endIndex-1</code>结束的子字符串。</li>
<li><code>indexOf(str)</code>: 返回字符串中第一次出现<code>str</code>的位置。</li>
<li><code>toLowerCase()</code>: 将字符串转换为小写。</li>
<li><code>toUpperCase()</code>: 将字符串转换为大写。</li>
<li><code>trim()</code>: 删除字符串前后的空格。</li>
<li><code>replace(oldChar, newChar)</code>: 将字符串中所有的<code>oldChar</code>替换为<code>newChar</code>。</li>
<li><code>split(delimiter)</code>: 根据分隔符<code>delimiter</code>将字符串分割成子字符串数组。</li>
</ul>
</li>
<li><h4 id="字符串不可变性"><a href="#字符串不可变性" class="headerlink" title="字符串不可变性"></a>字符串不可变性</h4><p>Java中的字符串是不可变的，也就是说一旦创建了一个字符串对象，它就不能被修改。因此，对于一个字符串的任何操作都会返回一个新的字符串对象。这个特性可以提高字符串处理的安全性和效率。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">str = str + <span class="string">&quot; world!&quot;</span>;</span><br><span class="line">System.out.println(str); <span class="comment">// 输出 &quot;Hello world!&quot;</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>str + &quot; world!&quot;</code>实际上是创建了一个新的字符串对象，并将其赋值给<code>str</code>变量。</p>
</li>
<li><h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p>字符串常量池</p>
<p>Java中的字符串常量池是一个特殊的内存区域，用于存储字符串常量。它的目的是避免重复创建相同内容的字符串对象，从而提高性能和节约内存。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str2); <span class="comment">// 输出 true</span></span><br><span class="line">System.out.println(str1 == str3); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>str1</code>和<code>str2</code>引用的是同一个字符串常量对象，因此它们相等；而<code>str3</code>则是通过构造函数创建的新的字符串对象，所以与<code>str1</code>和<code>str2</code>不相等。</p>
</li>
<li><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>String</code>类是Java编程语言中表示字符串的主要方式。它提供了很多方法来操作字符串，但是由于字符串的不可变性，每个操作都会创建一个新的字符串对象。同时，Java中的字符串常量池也是开发中需要注意的一个细节。</p>
</li>
</ul>
<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>Math类包含许多数学函数，例如sin，cos，tan，asin，acos，atan，sqrt，log等，这些函数可被直接调用而无需在程序中自己实现。</p>
<ul>
<li><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><ul>
<li><code>Math.PI</code>：返回π的值，即3.141592653589793。</li>
<li><code>Math.E</code>：返回自然对数的底数e，即2.718281828459045。</li>
</ul>
</li>
<li><h4 id="基本数学运算"><a href="#基本数学运算" class="headerlink" title="基本数学运算"></a>基本数学运算</h4><ul>
<li><code>Math.abs(x)</code>：返回 x 的绝对值。</li>
<li><code>Math.ceil(x)</code>：返回大于或等于 x 的最小整数。</li>
<li><code>Math.floor(x)</code>：返回小于或等于 x 的最大整数。</li>
<li><code>Math.round(x)</code>：返回最接近 x 的 long 或 double。</li>
<li><code>Math.max(x, y)</code>：返回 x 和 y 中的较大值。</li>
<li><code>Math.min(x, y)</code>：返回 x 和 y 中的较小值。</li>
<li><code>Math.pow(x, y)</code>：返回x的y次幂的值。</li>
<li><code>Math.sqrt(x)</code>：返回x的平方根的值。</li>
</ul>
</li>
<li><h4 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h4><ul>
<li><code>Math.sin(x)</code>：返回角度 x（以弧度为单位）的正弦值。</li>
<li><code>Math.cos(x)</code>：返回角度 x（以弧度为单位）的余弦值。</li>
<li><code>Math.tan(x)</code>：返回角度 x（以弧度为单位）的正切值。</li>
<li><code>Math.asin(x)</code>：返回 x 的反正弦值，以弧度为单位。</li>
<li><code>Math.acos(x)</code>：返回 x 的反余弦值，以弧度为单位。</li>
<li><code>Math.atan(x)</code>：返回 x 的反正切值，以弧度为单位。</li>
<li><code>Math.atan2(y, x)</code>：将笛卡尔坐标 (x, y) 转换为极坐标 (r, θ)，然后返回θ的值（以弧度为单位）。</li>
</ul>
</li>
<li><h4 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a>对数函数</h4><ul>
<li><code>Math.log(x)</code>：返回 x 的自然对数（以基数 e 为底数）。</li>
<li><code>Math.log10(x)</code>：返回 x 的常用对数（以基数 10 为底数）。</li>
<li><code>Math.exp(x)</code>：返回 e 的 x 次幂。</li>
</ul>
</li>
<li><h4 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h4><ul>
<li><code>Math.random()</code>：返回一个[0, 1)之间的随机浮点数。</li>
<li><code>Math.nextInt()</code>：返回一个随机的int值。</li>
<li><code>Math.nextDouble()</code>：返回一个随机的double值。</li>
</ul>
</li>
</ul>
<h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><p>Java的Date类是一个用于表示日期和时间的类。它存储了从1970年1月1日00:00:00 UTC开始所经过的毫秒数。</p>
<ul>
<li><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>要使用Date类，需要先创建一个实例对象。可以通过调用无参构造函数来创建一个Date对象，这将返回当前日期和时间。也可以传递一个long类型参数给构造函数，该参数表示自1970年1月1日00:00:00 UTC以来经过的毫秒数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个Date对象，表示当前日期和时间</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Date对象，表示1985年11月21日12:30:00</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">498080200000L</span>);</span><br></pre></td></tr></table></figure>

<p>Date类有几种方法可以获取或设置其表示的日期和时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前日期和时间</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取自1970年1月1日以来的毫秒数</span></span><br><span class="line"><span class="type">long</span> <span class="variable">milliseconds</span> <span class="operator">=</span> now.getTime();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Date对象转换为字符串，格式为EEE MMM dd HH:mm:ss zzz yyyy</span></span><br><span class="line"><span class="type">String</span> <span class="variable">dateString</span> <span class="operator">=</span> now.toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置Date对象的时间为指定的毫秒数</span></span><br><span class="line">now.setTime(<span class="number">1627893579000L</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>尽管Date类是Java中最常用的日期和时间处理类之一，但它有一些缺点。</p>
<p>首先，Date类不是线程安全的。如果多个线程同时修改同一个Date对象，则可能会导致不确定的行为。</p>
<p>其次，Date类提供了相对较少的日期和时间处理功能。例如，它不能处理时区信息，也不能计算日期之间的差异。</p>
<p>因此，在Java 8中引入了一个新的日期和时间API，即java.time包。如果要进行更高级的日期和时间处理，请考虑使用这个API。</p>
</li>
</ul>
<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p>Calendar类是一个抽象类，用于表示日历并进行日期计算。它提供了各种获取年、月、日、时、分、秒等方法。</p>
<ul>
<li><h4 id="创建Calendar实例"><a href="#创建Calendar实例" class="headerlink" title="创建Calendar实例"></a>创建Calendar实例</h4><p>要创建一个Calendar对象，可以使用以下方法之一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance(); <span class="comment">// 使用默认时区和当前时间创建Calendar对象</span></span><br><span class="line"><span class="comment">// 或者指定时区和时间创建Calendar对象：</span></span><br><span class="line"><span class="type">TimeZone</span> <span class="variable">tz</span> <span class="operator">=</span> TimeZone.getTimeZone(<span class="string">&quot;GMT+8&quot;</span>); <span class="comment">// 东八区时区</span></span><br><span class="line">cal = Calendar.getInstance(tz);</span><br><span class="line">cal.set(<span class="number">2021</span>, <span class="number">8</span>, <span class="number">6</span>); <span class="comment">// 设置为2021年9月6日</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="获取日期和时间信息"><a href="#获取日期和时间信息" class="headerlink" title="获取日期和时间信息"></a>获取日期和时间信息</h4><p>要获取Calendar对象表示的日期和时间信息，可以使用以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> cal.get(Calendar.YEAR); <span class="comment">// 获取年份</span></span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> cal.get(Calendar.MONTH); <span class="comment">// 获取月份（0-11）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">date</span> <span class="operator">=</span> cal.get(Calendar.DATE); <span class="comment">// 获取日期</span></span><br><span class="line"><span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> cal.get(Calendar.HOUR_OF_DAY); <span class="comment">// 获取小时（24小时制）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> cal.get(Calendar.MINUTE); <span class="comment">// 获取分钟</span></span><br><span class="line"><span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> cal.get(Calendar.SECOND); <span class="comment">// 获取秒钟</span></span><br><span class="line"><span class="type">int</span> <span class="variable">millisecond</span> <span class="operator">=</span> cal.get(Calendar.MILLISECOND); <span class="comment">// 获取毫秒数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> cal.get(Calendar.DAY_OF_WEEK); <span class="comment">// 获取星期几（1-7，其中1表示周日）</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="修改日期和时间信息"><a href="#修改日期和时间信息" class="headerlink" title="修改日期和时间信息"></a>修改日期和时间信息</h4><p>要修改Calendar对象表示的日期和时间信息，可以使用以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cal.set(Calendar.YEAR, <span class="number">2022</span>); <span class="comment">// 修改年份为2022</span></span><br><span class="line">cal.set(Calendar.MONTH, Calendar.OCTOBER); <span class="comment">// 修改月份为10（Calendar.OCTOBER=9）</span></span><br><span class="line">cal.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>); <span class="comment">// 修改日期为1</span></span><br><span class="line">cal.set(Calendar.HOUR_OF_DAY, <span class="number">10</span>); <span class="comment">// 修改小时为10</span></span><br><span class="line">cal.set(Calendar.MINUTE, <span class="number">30</span>); <span class="comment">// 修改分钟为30</span></span><br><span class="line">cal.set(Calendar.SECOND, <span class="number">0</span>); <span class="comment">// 修改秒钟为0</span></span><br><span class="line">cal.set(Calendar.MILLISECOND, <span class="number">0</span>); <span class="comment">// 修改毫秒数为0</span></span><br></pre></td></tr></table></figure>

</li>
<li><h4 id="日期和时间的加减"><a href="#日期和时间的加减" class="headerlink" title="日期和时间的加减"></a>日期和时间的加减</h4><p>要对Calendar对象表示的日期和时间进行加减操作，可以使用以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cal.add(Calendar.YEAR, <span class="number">1</span>); <span class="comment">// 年份加1</span></span><br><span class="line">cal.add(Calendar.MONTH, -<span class="number">3</span>); <span class="comment">// 月份减3</span></span><br><span class="line">cal.add(Calendar.DAY_OF_MONTH, <span class="number">7</span>); <span class="comment">// 日期加7</span></span><br><span class="line">cal.add(Calendar.HOUR_OF_DAY, <span class="number">4</span>); <span class="comment">// 小时加4</span></span><br><span class="line">cal.add(Calendar.MINUTE, -<span class="number">30</span>); <span class="comment">// 分钟减30</span></span><br><span class="line">cal.add(Calendar.SECOND, <span class="number">0</span>); <span class="comment">// 秒钟不变</span></span><br><span class="line">cal.add(Calendar.MILLISECOND, <span class="number">500</span>); <span class="comment">// 毫秒数加500</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="日期和时间的比较"><a href="#日期和时间的比较" class="headerlink" title="日期和时间的比较"></a>日期和时间的比较</h4><p>要比较两个Calendar对象表示的日期和时间的先后顺序，可以使用以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> cal1.compareTo(cal2); <span class="comment">// 返回值为负数、零或正数，分别表示cal1在cal2之前、相等或之后</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isBefore</span> <span class="operator">=</span> cal1.before(cal2); <span class="comment">// 返回true表示cal1在cal2之前</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isAfter</span> <span class="operator">=</span> cal1.after(cal2); <span class="comment">// 返回true表示cal1在cal2之后</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="格式化日期和时间"><a href="#格式化日期和时间" class="headerlink" title="格式化日期和时间"></a>格式化日期和时间</h4><p>要将Calendar对象表示的日期和时间格式化成字符串，可以使用以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sdf.format(cal.getTime()); <span class="comment">// 将Calendar对象表示的日期和时间格式化为字符串</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>以上就是Java中Calendar类的一些常用方法，它有很多其他功能的方法，需要根据具体需求进行使用。</p>
<h3 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h3><p><code>SimpleDateFormat</code>是Java中用于将日期对象格式化为字符串或将字符串解析为日期对象的类。它可以接受任何形式的日历日期，并将其转换为指定格式的字符串。</p>
<p>以下是一些常见的解析和格式化的示例：</p>
<ul>
<li><h4 id="解析字符串为日期对象"><a href="#解析字符串为日期对象" class="headerlink" title="解析字符串为日期对象"></a>解析字符串为日期对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> <span class="string">&quot;2022-12-31&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(dateStr);</span><br></pre></td></tr></table></figure>

<p>上面的代码将字符串 “2022-12-31” 解析为一个 <code>java.util.Date</code> 对象。</p>
</li>
<li><h4 id="将日期对象格式化为字符串"><a href="#将日期对象格式化为字符串" class="headerlink" title="将日期对象格式化为字符串"></a>将日期对象格式化为字符串</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">formattedDate</span> <span class="operator">=</span> sdf.format(date);</span><br></pre></td></tr></table></figure>

<p>上面的代码将当前日期和时间格式化成“年-月-日 时：分：秒”的格式的字符串。</p>
</li>
<li><h4 id="模式字母含义"><a href="#模式字母含义" class="headerlink" title="模式字母含义"></a>模式字母含义</h4><p>以下是常见的模式字母以及它们在格式化和解析日期时的含义：</p>
<table>
<thead>
<tr>
<th>模式字母</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>年份</td>
</tr>
<tr>
<td>M</td>
<td>月份</td>
</tr>
<tr>
<td>d</td>
<td>日期</td>
</tr>
<tr>
<td>H</td>
<td>小时（0-23）</td>
</tr>
<tr>
<td>h</td>
<td>小时（1-12）</td>
</tr>
<tr>
<td>m</td>
<td>分钟</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
<tr>
<td>S</td>
<td>毫秒</td>
</tr>
</tbody></table>
<p>除了这些模式字母之外，还有一些可以用来表示文本和符号，如下所示：</p>
<table>
<thead>
<tr>
<th>模式字母</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>G</td>
<td>公元</td>
</tr>
<tr>
<td>E</td>
<td>星期几</td>
</tr>
<tr>
<td>a</td>
<td>上午&#x2F;下午</td>
</tr>
<tr>
<td>z</td>
<td>时区</td>
</tr>
</tbody></table>
</li>
<li><h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><p><code>SimpleDateFormat</code>是一个非线程安全的类。这意味着在多个线程之间共享同一个 <code>SimpleDateFormat</code> 实例可能会导致问题。为了避免这种情况，应该将每个线程使用的 <code>SimpleDateFormat</code> 实例封装在 <code>ThreadLocal</code> 对象中。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; threadLocalDateFormat = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> SimpleDateFormat <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">parseDate</span><span class="params">(String dateStr)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> threadLocalDateFormat.get();</span><br><span class="line">    <span class="keyword">return</span> sdf.parse(dateStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">formatDate</span><span class="params">(Date date)</span> &#123;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> threadLocalDateFormat.get();</span><br><span class="line">    <span class="keyword">return</span> sdf.format(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>上面的代码创建了一个 <code>ThreadLocal</code> 对象来保存每个线程使用的 <code>SimpleDateFormat</code> 实例。这样，每个线程都可以安全地使用自己的 <code>SimpleDateFormat</code> 实例，而不必担心线程安全问题。</p>
<h3 id="FileInputStream和FileOutputStream类"><a href="#FileInputStream和FileOutputStream类" class="headerlink" title="FileInputStream和FileOutputStream类"></a>FileInputStream和FileOutputStream类</h3><p>FileInputStream和FileOutputStream是Java I&#x2F;O操作中常用的类，它们分别用于读取和写入文件数据。下面详细讲解这两个类的使用方法和注意事项。</p>
<ul>
<li><h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure>

<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><ul>
<li><code>available()</code> 返回剩余可用的字节数。</li>
<li><code>close()</code> 关闭输入流。</li>
<li><code>mark(int readlimit)</code> 在当前位置做标记，最多偏移<code>readlimit</code>个字节。</li>
<li><code>markSupported()</code> 判断此输入流是否支持 mark 和 reset 方法。</li>
<li><code>read()</code> 从输入流中读取一个字节数据并返回；若已到达文件结尾，则返回 -1。</li>
<li><code>read(byte[] b)</code> 从输入流中最多读取 b.length 个字节的数据，并存储在缓冲区 b 中，返回实际读取的字节数。</li>
<li><code>read(byte[] b, int off, int len)</code> 从输入流中最多读取 len 个字节的数据，并存储在缓冲区 b 中，从数组 b 的下标 off 处开始存储，返回实际读取的字节数。</li>
<li><code>reset()</code> 将输入流重新定位到最近一次调用 mark 方法所做的位置。</li>
<li><code>skip(long n)</code> 跳过和丢弃此输入流中数据的 n 个字节。</li>
</ul>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="keyword">while</span> ((length = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, length));</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h4><h5 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileOutputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileOutputStream</span><span class="params">(File file, <span class="type">boolean</span> append)</span> <span class="keyword">throws</span> FileNotFoundException</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileOutputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileOutputStream</span><span class="params">(String name, <span class="type">boolean</span> append)</span> <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure>

<h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><ul>
<li><code>close()</code> 关闭输出流。</li>
<li><code>flush()</code> 将缓冲区的数据写入文件中。</li>
<li><code>write(byte[] b)</code> 将 b.length 个字节从指定的 byte 数组写入此输出流中。</li>
<li><code>write(byte[] b, int off, int len)</code> 将 len 个字节从指定的 byte 数组写入此输出流中，从数组的第 off 个字节开始写入。</li>
<li><code>write(int b)</code> 将一个字节写入该输出流。</li>
</ul>
<h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="string">&quot;Hello World!&quot;</span>.getBytes();</span><br><span class="line">fos.write(buffer);</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>以上是 FileInputStream 和 FileOutputStream 的详细介绍和使用方法。在使用时需要注意正确关闭输入输出流、处理异常等问题。</p>
<h3 id="InputStream和OutputStream类"><a href="#InputStream和OutputStream类" class="headerlink" title="InputStream和OutputStream类"></a>InputStream和OutputStream类</h3><p>Java的<code>InputStream</code>和<code>OutputStream</code>类是用于读写二进制数据的抽象类。它们是Java IO API的一部分，并且是Java中处理文件、网络连接和其他输入&#x2F;输出操作的关键类。</p>
<ul>
<li><h4 id="InputStream类"><a href="#InputStream类" class="headerlink" title="InputStream类"></a>InputStream类</h4><p><code>InputStream</code>类是所有输入流的超类。它具有以下一些常用方法：</p>
<ul>
<li><code>int read()</code>: 从流中读取下一个字节</li>
<li><code>int read(byte[] b)</code>: 将流中的数据读入到字节数组中</li>
<li><code>int read(byte[] b, int off, int len)</code>: 读取指定长度的字节到缓冲区中，从给定偏移量开始存储。</li>
<li><code>long skip(long n)</code>: 跳过并丢弃输入流中的n个字节</li>
<li><code>int available()</code>: 返回可以从此输入流中读取（或跳过）的字节数</li>
<li><code>void close()</code>: 关闭该输入流并释放与之关联的所有系统资源</li>
</ul>
<p><code>InputStream</code>还有许多其他方法，但上述方法是使用频率最高的。</p>
</li>
<li><h4 id="OutputStream类"><a href="#OutputStream类" class="headerlink" title="OutputStream类"></a>OutputStream类</h4><p><code>OutputStream</code>类是所有输出流的超类。它具有以下一些常用方法：</p>
<ul>
<li><code>void write(int b)</code>: 将指定的字节写入此输出流</li>
<li><code>void write(byte[] b)</code>: 将指定的字节数组全部写入此输出流</li>
<li><code>void write(byte[] b, int off, int len)</code>: 将指定字节数组的一部分写入此输出流</li>
<li><code>void flush()</code>: 刷新此输出流并强制将任何缓冲的输出字节被写出</li>
<li><code>void close()</code>: 关闭该输出流并释放与之关联的所有系统资源</li>
</ul>
<p><code>OutputStream</code>还有许多其他方法，但上述方法是使用频率最高的。</p>
</li>
<li><h4 id="InputStream和OutputStream的应用"><a href="#InputStream和OutputStream的应用" class="headerlink" title="InputStream和OutputStream的应用"></a>InputStream和OutputStream的应用</h4><p>这些类可用于读取文件、从网络连接接收数据以及向文件或网络连接发送数据。例如，可以使用以下代码片段从文件中读取字节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> input.read(buffer);</span><br><span class="line">    <span class="keyword">while</span> (len != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理读取到的内容</span></span><br><span class="line">        len = input.read(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，可以使用以下代码片段将字节写入文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">byte</span>[] data = <span class="string">&quot;Hello, world!&quot;</span>.getBytes();</span><br><span class="line">    output.write(data);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>总之，<code>InputStream</code>和<code>OutputStream</code>是Java IO API的核心部分，它们提供了一种方便的方式来读取和写入二进制数据。</p>
<h3 id="Reader和Writer类"><a href="#Reader和Writer类" class="headerlink" title="Reader和Writer类"></a>Reader和Writer类</h3><p>Java中的<code>Reader</code>和<code>Writer</code>类是用于读写字符数据的抽象类。它们也是Java IO API的一部分，与<code>InputStream</code>和<code>OutputStream</code>类对应。</p>
<ul>
<li><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p><code>Reader</code>类是所有输入流的超类。它具有以下一些常用方法：</p>
<ul>
<li><code>int read()</code>: 从流中读取一个字符</li>
<li><code>int read(char[] cbuf)</code>: 将字符读入数组中，并返回读取的字符数</li>
<li><code>int read(char[] cbuf, int off, int len)</code>: 读取指定长度的字符到缓冲区中，从给定偏移量开始存储。</li>
<li><code>boolean ready()</code>: 返回此流是否已准备好被读取</li>
<li><code>void close()</code>: 关闭该输入流并释放与之关联的所有系统资源</li>
</ul>
<p><code>Reader</code>还有许多其他方法，但上述方法是使用频率最高的。</p>
</li>
<li><h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><p><code>Writer</code>类是所有输出流的超类。它具有以下一些常用方法：</p>
<ul>
<li><code>void write(int c)</code>: 写出单个字符</li>
<li><code>void write(String str)</code>: 写出字符串</li>
<li><code>void write(char[] cbuf)</code>: 将字符数组全部写出</li>
<li><code>void write(char[] cbuf, int off, int len)</code>: 将字符数组的一部分写出</li>
<li><code>void flush()</code>: 刷新此输出流并强制将任何缓冲的输出字符被写出</li>
<li><code>void close()</code>: 关闭该输出流并释放与之关联的所有系统资源</li>
</ul>
<p><code>Writer</code>还有许多其他方法，但上述方法是使用频率最高的。</p>
</li>
<li><h4 id="Reader和Writer的应用"><a href="#Reader和Writer的应用" class="headerlink" title="Reader和Writer的应用"></a>Reader和Writer的应用</h4><p>这些类可用于读取文本文件、从网络连接接收数据并解析字符，以及向文件或网络连接发送字符。例如，可以使用以下代码片段从文件中读取字符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> reader.read(buffer);</span><br><span class="line">    <span class="keyword">while</span> (len != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理读取到的内容</span></span><br><span class="line">        len = reader.read(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，可以使用以下代码片段向文件写入字符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;file.txt&quot;</span>)) &#123;</span><br><span class="line">    writer.write(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>总之，<code>Reader</code>和<code>Writer</code>是Java IO API的核心部分，它们提供了一种方便的方式来读取和写入字符数据。</p>
<h3 id="Random类-随机数"><a href="#Random类-随机数" class="headerlink" title="Random类(随机数)"></a>Random类(随机数)</h3><p><code>java.util.Random</code>是Java中用于生成伪随机数的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Random对象</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机整数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">randomNumber</span> <span class="operator">=</span> random.nextInt(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成整数范围为-2147483648到2147483647</span></span><br><span class="line">System.out.println(<span class="string">&quot;随机整数：&quot;</span> + randomNumber);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成1到10之间的随机整数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">randomNumberInRange</span> <span class="operator">=</span> random.nextInt(<span class="number">10</span>) + <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成整数范围为0到9，再加1映射到1到10</span></span><br><span class="line">System.out.println(<span class="string">&quot;1到10之间的随机整数：&quot;</span> + randomNumberInRange);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机浮点数</span></span><br><span class="line"><span class="type">double</span> <span class="variable">randomDouble</span> <span class="operator">=</span> random.nextDouble(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成浮点数范围为0.0到1.0</span></span><br><span class="line">System.out.println(<span class="string">&quot;随机浮点数：&quot;</span> + randomDouble);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机布尔值</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">randomBoolean</span> <span class="operator">=</span> random.nextBoolean(); <span class="comment">// 生成true或false</span></span><br><span class="line">System.out.println(<span class="string">&quot;随机布尔值：&quot;</span> + randomBoolean);</span><br></pre></td></tr></table></figure>

<h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p><code>StringBuilder</code>是Java中提供的可变字符串类，用于在处理大量字符串拼接或修改操作时提供高效的性能。与<code>String</code>类不同，<code>StringBuilder</code>对象是可变的，可以直接在原始对象上进行修改，而不会创建新的对象。这样可以避免频繁创建新的字符串对象，从而减少内存开销和提高性能。</p>
<ul>
<li><h4 id="StringBuilder类的主要特点包括"><a href="#StringBuilder类的主要特点包括" class="headerlink" title="StringBuilder类的主要特点包括"></a><code>StringBuilder</code>类的主要特点包括</h4><ol>
<li>可变性：<code>StringBuilder</code>对象的长度和内容是可变的，可以直接对其进行修改，包括插入、删除、替换字符等操作。</li>
<li>缓冲区：<code>StringBuilder</code>类内部使用了一个缓冲区（buffer）来存储字符串内容，可以动态扩展和收缩缓冲区的大小，从而避免了频繁分配和回收内存的开销。</li>
<li>非线程安全：<code>StringBuilder</code>类不是线程安全的，不适合在多线程环境下共享和修改。如果需要在多线程环境下使用可变字符串，应该使用<code>StringBuffer</code>类，它提供了线程安全的操作。</li>
</ol>
</li>
<li><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的StringBuilder对象</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加字符串</span></span><br><span class="line">sb.append(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">System.out.println(sb.toString()); <span class="comment">// 输出: Hello World</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置插入字符</span></span><br><span class="line">sb.insert(<span class="number">5</span>, <span class="string">&quot;,&quot;</span>); <span class="comment">// 在索引为5的位置插入逗号</span></span><br><span class="line">System.out.println(sb.toString()); <span class="comment">// 输出: Hello, World</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定范围的字符</span></span><br><span class="line">sb.delete(<span class="number">5</span>, <span class="number">7</span>); <span class="comment">// 删除索引为5到6的字符</span></span><br><span class="line">System.out.println(sb.toString()); <span class="comment">// 输出: Hello World</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换指定范围的字符</span></span><br><span class="line">sb.replace(<span class="number">6</span>, <span class="number">11</span>, <span class="string">&quot;Java&quot;</span>); <span class="comment">// 将索引为6到10的字符替换为Java</span></span><br><span class="line">System.out.println(sb.toString()); <span class="comment">// 输出: Hello Java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转字符串</span></span><br><span class="line">sb.reverse();</span><br><span class="line">System.out.println(sb.toString()); <span class="comment">// 输出: avaJ olleH</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="StringBuilder常用方法"><a href="#StringBuilder常用方法" class="headerlink" title="StringBuilder常用方法"></a>StringBuilder常用方法</h4><ol>
<li>append(String str): 将指定的字符串追加到 StringBuilder 对象的末尾。</li>
<li>insert(int index, String str): 在指定位置插入字符串。</li>
<li>delete(int start, int end): 删除指定范围内的字符。</li>
<li>replace(int start, int end, String str): 替换指定范围内的字符为指定字符串。</li>
<li>reverse(): 反转 StringBuilder 对象中的字符序列。</li>
<li>length(): 获取 StringBuilder 对象中字符序列的长度。</li>
<li>capacity(): 获取 StringBuilder 对象的容量。</li>
<li>toString(): 将 StringBuilder 对象转换为 String 对象。</li>
</ol>
</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Java的集合是一组框架类，用于存储和操作对象。它们提供了一种更便捷、高效的方式来管理复杂数据结构，并包括许多有用的方法和算法。这里我们介绍Java中常用的集合类。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p><code>List</code>接口代表一个元素有序并且可重复的集合。它具有以下一些常用方法：</p>
<ul>
<li><code>void add(E e)</code>: 在列表末尾添加指定元素</li>
<li><code>void add(int index, E element)</code>: 在指定位置插入指定元素</li>
<li><code>E get(int index)</code>: 返回指定位置的元素</li>
<li><code>int indexOf(Object o)</code>: 返回此列表中指定元素第一次出现的位置</li>
<li><code>boolean isEmpty()</code>: 如果此列表不包含元素，则返回true</li>
<li><code>int size()</code>: 返回此列表中元素的数量</li>
<li><code>void clear()</code>: 从列表中移除所有元素</li>
</ul>
<p>常见的实现类有<code>ArrayList</code>和<code>LinkedList</code>。</p>
<p><code>ArrayList</code>和<code>LinkedList</code>都是Java中的集合框架（collection framework）类，它们实现了<code>List</code>接口，提供了一种有序的、可重复的数据存储方式。虽然这两个类都可以用于存储相同类型的对象，但它们在内部实现和性能方面存在着很大的区别。</p>
<ul>
<li><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p><code>ArrayList</code>是一种基于动态数组实现的集合类，它可以根据需要自动扩展容量以存储更多的元素。下面是<code>ArrayList</code>的一些特点：</p>
<ul>
<li>随机访问：<code>ArrayList</code>支持随机访问，也就是通过索引获取元素，在时间复杂度上是O(1)的。</li>
<li>插入和删除：由于<code>ArrayList</code>底层是一个数组，因此在中间或开头插入或删除元素时需要将其它元素全部向右或向左移动，导致时间复杂度为O(n)。</li>
<li>迭代器：<code>ArrayList</code>提供了快速失败（fail-fast）的迭代器，这意味着当多个线程对<code>ArrayList</code>进行并发修改操作时会抛出<code>ConcurrentModificationException</code>异常来防止不正确的操作。</li>
<li>线程安全：<code>ArrayList</code>不是线程安全的，如果多个线程同时对同一个<code>ArrayList</code>实例进行操作，可能会导致数据不一致的问题。</li>
</ul>
</li>
<li><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p><code>LinkedList</code>是一种基于链表实现的集合类，它可以高效地插入、删除元素，但随机访问则比较低效。下面是<code>LinkedList</code>的一些特点：</p>
<ul>
<li>插入和删除：由于<code>LinkedList</code>底层是一个双向链表，因此在中间或开头插入或删除元素时只需要修改相邻节点的指针，导致时间复杂度为O(1)。</li>
<li>随机访问：<code>LinkedList</code>不支持随机访问，因为要遍历整个链表才能获取到指定位置的元素，导致时间复杂度为O(n)。</li>
<li>迭代器：<code>LinkedList</code>同样提供了快速失败（fail-fast）的迭代器，防止并发修改操作导致的异常。</li>
<li>线程安全：<code>LinkedList</code>同样不是线程安全的。</li>
</ul>
</li>
<li><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>综上所述，<code>ArrayList</code>适合读取数据多、插入&#x2F;删除操作少的场景，而<code>LinkedList</code>适合插入&#x2F;删除操作多、随机访问较少的场景。同时，要注意其线程安全性问题，如果需要在多线程环境下使用这两个类，需要采用线程安全的方式进行操作。</p>
</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><code>Set</code>接口代表一个元素无序并且不可重复的集合。它具有以下一些常用方法：</p>
<ul>
<li><code>boolean add(E e)</code>: 将指定元素添加到该集合中，如果已存在则不添加</li>
<li><code>boolean remove(Object o)</code>: 从集合中删除指定元素</li>
<li><code>boolean contains(Object o)</code>: 如果集合包含指定元素，则返回true</li>
<li><code>int size()</code>: 返回集合中元素的数量</li>
<li><code>boolean isEmpty()</code>: 如果集合不包含元素，则返回true</li>
<li><code>void clear()</code>: 从集合中移除所有元素</li>
</ul>
<p>常见的实现类有<code>HashSet</code>和<code>TreeSet</code>。</p>
<p><code>HashSet</code>和<code>TreeSet</code>都是Java中的集合类，它们都实现了<code>Set</code>接口。但是它们之间有很大的区别。</p>
<ul>
<li><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p><code>HashSet</code>是一个基于哈希表的无序集合，可以存储不同的元素。它不保证元素的顺序，也不保证元素的插入顺序和取出顺序一致。在<code>HashSet</code>中，元素按照哈希算法来存储，因此插入、删除和查找等操作的时间复杂度为O(1)。这使得<code>HashSet</code>非常适合于快速查找和去重。</p>
<p>下面是一些<code>HashSet</code>的使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个HashSet</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">set.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历元素</span></span><br><span class="line"><span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断元素是否存在</span></span><br><span class="line"><span class="keyword">if</span> (set.contains(<span class="string">&quot;banana&quot;</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">set.remove(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断集合是否为空</span></span><br><span class="line"><span class="keyword">if</span> (set.isEmpty()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;空&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p><code>TreeSet</code>是一个基于红黑树实现的有序集合，可以存储不同的元素。在<code>TreeSet</code>中，元素按照自然顺序或者指定的比较器顺序进行排序。因此，<code>TreeSet</code>中的元素是有序的。<code>TreeSet</code>提供了一些方法来获取、删除和搜索集合中的元素，这些操作的时间复杂度为O(log n)。</p>
<p>下面是一些<code>TreeSet</code>的使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个TreeSet</span></span><br><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">set.add(<span class="number">3</span>);</span><br><span class="line">set.add(<span class="number">1</span>);</span><br><span class="line">set.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历元素</span></span><br><span class="line"><span class="keyword">for</span> (Integer i : set) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第一个和最后一个元素</span></span><br><span class="line">System.out.println(set.first());</span><br><span class="line">System.out.println(set.last());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">set.remove(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断集合是否为空</span></span><br><span class="line"><span class="keyword">if</span> (set.isEmpty()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;空&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在使用<code>TreeSet</code>时，被存储的元素必须实现了<code>Comparable</code>接口，或者在创建<code>TreeSet</code>对象时指定了一个比较器来进行比较。否则会抛出<code>ClassCastException</code>异常。</p>
</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><code>Map</code>接口代表一组键值对，并且每个键只能映射到一个值。它具有以下一些常用方法：</p>
<ul>
<li><code>V put(K key, V value)</code>: 将指定的值与此映射中的指定键关联</li>
<li><code>V get(Object key)</code>: 返回给定键所映射的值，如果该键不在此映射中，则返回null</li>
<li><code>boolean containsKey(Object key)</code>: 如果此映射包含指定键的映射关系，则返回true</li>
<li><code>boolean containsValue(Object value)</code>: 如果此映射将一个或多个键映射到指定值，则返回true</li>
<li><code>int size()</code>: 返回此映射中的键-值映射关系数</li>
<li><code>void clear()</code>: 从映射中移除所有映射关系</li>
</ul>
<p>常见的实现类有<code>HashMap</code>和<code>TreeMap</code>。</p>
<p><code>HashMap</code>和<code>TreeMap</code>都是Java中的映射表（Map）类，它们都实现了<code>Map</code>接口。但是它们之间有很大的区别。</p>
<ul>
<li><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p><code>HashMap</code>是一个基于哈希表的映射表，它的键值对可以存储不同类型的元素，并且键不能为空。在<code>HashMap</code>中，元素按照哈希算法来存储，因此插入、删除和查找等操作的时间复杂度为O(1)。这使得<code>HashMap</code>非常适合于快速查找和存储。</p>
<p>下面是一些<code>HashMap</code>的使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个HashMap</span></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加键值对</span></span><br><span class="line">map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">10</span>);</span><br><span class="line">map.put(<span class="string">&quot;banana&quot;</span>, <span class="number">20</span>);</span><br><span class="line">map.put(<span class="string">&quot;orange&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键对应的值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> map.get(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历键值对</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否包含某个键或值</span></span><br><span class="line"><span class="keyword">if</span> (map.containsKey(<span class="string">&quot;apple&quot;</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;包含键&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (map.containsValue(<span class="number">20</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;包含值&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除键值对</span></span><br><span class="line">map.remove(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断集合是否为空</span></span><br><span class="line"><span class="keyword">if</span> (map.isEmpty()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;空&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p><code>TreeMap</code>是一个基于红黑树实现的有序映射表，它的键值对可以存储不同类型的元素，并且键不能为空。在<code>TreeMap</code>中，元素按照自然顺序或者指定的比较器顺序进行排序。因此，<code>TreeMap</code>中的键是有序的。<code>TreeMap</code>提供了一些方法来获取、删除和搜索映射表中的键值对，这些操作的时间复杂度为O(log n)。</p>
<p>下面是一些<code>TreeMap</code>的使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个TreeMap</span></span><br><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加键值对</span></span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;orange&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键对应的值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历键值对</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第一个和最后一个键值对</span></span><br><span class="line">System.out.println(map.firstEntry());</span><br><span class="line">System.out.println(map.lastEntry());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除键值对</span></span><br><span class="line">map.remove(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断集合是否为空</span></span><br><span class="line"><span class="keyword">if</span> (map.isEmpty()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;空&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在使用<code>TreeMap</code>时，被存储的键必须实现了<code>Comparable</code>接口，或者在创建<code>TreeMap</code>对象时指定了一个比较器来进行比较。否则会抛出<code>ClassCastException</code>异常。</p>
</li>
</ul>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p><code>Queue</code>接口代表一组元素按照一定规则排序的集合。它具有以下一些常用方法：</p>
<ul>
<li><code>boolean add(E e)</code>: 将指定元素插入此队列（如果立即可行且不会违反容量限制），成功时返回true，如果当前没有可用空间，则抛出IllegalStateException。</li>
<li><code>E remove()</code>: 检索并删除此队列的头，如果此队列为空，则抛出NoSuchElementException。</li>
<li><code>E peek()</code>: 获取但不移除此队列的头；如果此队列为空，则返回null。</li>
<li><code>boolean offer(E e)</code>: 将指定元素插入此队列（如果立即可行且不会违反容量限制），成功时返回true，如果当前没有可用空间，则返回false。</li>
</ul>
<p>常见的实现类有<code>PriorityQueue</code>和<code>ArrayDeque</code>。</p>
<p><code>PriorityQueue</code>和<code>ArrayDeque</code>都是Java中的队列类，它们实现了<code>Queue</code>接口。但是它们之间有很大的区别。</p>
<ul>
<li><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p><code>PriorityQueue</code>是一个基于小根堆实现的优先队列，可以存储不同类型的元素，并且元素必须实现了<code>Comparable</code>接口或者在创建<code>PriorityQueue</code>对象时指定了一个比较器来进行比较。在<code>PriorityQueue</code>中，元素按照优先级来排队，具有更高优先级的元素先被取出。<code>PriorityQueue</code>提供了一些方法来添加、删除和获取队列中的元素，这些操作的时间复杂度为O(log n)。</p>
<p>下面是一些<code>PriorityQueue</code>的使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个PriorityQueue</span></span><br><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">queue.offer(<span class="number">3</span>);</span><br><span class="line">queue.offer(<span class="number">1</span>);</span><br><span class="line">queue.offer(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取队首元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> queue.peek();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历元素</span></span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;空&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h4><p><code>ArrayDeque</code>实际上是一个由数组实现的双端队列，可以存储不同类型的元素。在<code>ArrayDeque</code>中，元素可以从两端入队和出队。<code>ArrayDeque</code>提供了一些方法来添加、删除和获取队列中的元素，这些操作的时间复杂度为O(1)。</p>
<p>下面是一些<code>ArrayDeque</code>的使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个ArrayDeque</span></span><br><span class="line">Deque&lt;String&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">deque.offerFirst(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">deque.offerLast(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">deque.offerLast(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取队首和队尾元素</span></span><br><span class="line"><span class="type">String</span> <span class="variable">head</span> <span class="operator">=</span> deque.peekFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">tail</span> <span class="operator">=</span> deque.peekLast();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历元素</span></span><br><span class="line"><span class="keyword">for</span> (String s : deque) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">deque.pollFirst();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (deque.isEmpty()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;空&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在使用<code>ArrayDeque</code>时，可以选择将其作为栈（先进后出）或队列（先进先出）来使用。也就是说，<code>ArrayDeque</code>既可以从头部入队、从头部出队，也可以从尾部入队、从尾部出队。</p>
</li>
</ul>
<p>以上是Java中最常用的集合类，它们提供了一种方便、快捷的方式来存储和操作数据。这些集合类具有许多其他方法和属性，可以根据实际需求进行使用。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>Java多线程是Java语言中的一个重要特性，它允许应用程序在同一时间内执行多个任务。多线程可以提高程序的性能和响应能力，因为它允许多个线程同时运行。</p>
<p>下面是Java多线程的详细解释：</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是一个轻量级进程，它使用共享内存模型实现并发执行。在Java中，一个线程由Thread类表示。创建一个新线程的方式有两种，分别是继承Thread类和实现Runnable接口。当一个线程启动后，它会执行run方法中的代码，这是每个线程必须实现的核心方法。</p>
<ul>
<li><h4 id="继承Thread类创建线程"><a href="#继承Thread类创建线程" class="headerlink" title="继承Thread类创建线程"></a>继承Thread类创建线程</h4><p>通过继承Thread类来创建线程需要定义一个类，并且重写Thread类的run()方法。当线程被启动时，它会执行run()方法中的代码。这种方法比较简单，但是它有一个缺点，即Java不支持多重继承。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程的执行逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; is running.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并启动线程</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="实现Runnable接口创建线程"><a href="#实现Runnable接口创建线程" class="headerlink" title="实现Runnable接口创建线程"></a>实现Runnable接口创建线程</h4><p>通过实现Runnable接口来创建线程需要定义一个类，并且实现Runnable接口中的run()方法。然后要使用Thread类的构造函数将该类的实例作为参数来创建一个新的线程对象。这种方法优于继承Thread类，因为Java支持实现多个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程的执行逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; is running.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并启动线程</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">runnable1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable1);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">runnable2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable2);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="线程睡眠"><a href="#线程睡眠" class="headerlink" title="线程睡眠"></a>线程睡眠</h4><p>有时候我们需要让线程暂停一段时间，这时可以使用Thread类的sleep()方法。Thread.sleep()方法允许线程暂停指定的时间（以毫秒为单位）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// handle exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="加入线程"><a href="#加入线程" class="headerlink" title="加入线程"></a>加入线程</h4><p>有时候我们需要等待一个线程完成后才能继续执行其他代码，这时可以使用Thread类的join()方法。调用该方法会使当前线程等待被调用的线程结束后再继续执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">myThread.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    myThread.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// handle exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p>Java中的线程有6种状态，分别是：</p>
<ol>
<li><p>NEW（新建）：当线程对象被创建但还没有调用start()方法时，线程处于新建状态。</p>
</li>
<li><p>RUNNABLE（就绪）：当线程调用start()方法后，线程处于就绪状态，等待系统分配资源，进行运行。</p>
</li>
<li><p>BLOCKED（阻塞）：当一个线程想要获取一个被其他线程持有的锁时，它会进入阻塞状态。如果锁被释放，该线程将变为就绪状态。</p>
</li>
<li><p>WAITING（等待）：当线程调用了如下方法之一时，该线程进入等待状态：</p>
<ul>
<li>Object.wait()</li>
<li>Thread.join()</li>
<li>LockSupport.park()</li>
</ul>
<p>等待状态的线程需要等待其他线程执行特定的动作来唤醒他们，才能转换为就绪状态。</p>
</li>
<li><p>TIMED_WAITING（计时等待）：当线程调用以下方法之一时，该线程进入计时等待状态：</p>
<ul>
<li>Thread.sleep()</li>
<li>Object.wait() 带超时参数</li>
<li>Thread.join() 带超时参数</li>
<li>LockSupport.parkNanos()</li>
<li>LockSupport.parkUntil()</li>
</ul>
<p>计时等待和等待状态类似，只是等待时间有限制，超过指定时间后线程自动进入就绪状态。</p>
</li>
<li><p>TERMINATED（终止）：当线程执行完run()方法或者发生了未捕获的异常时，线程将进入终止状态。</p>
</li>
</ol>
</li>
</ul>
<p>以上是Java多线程中线程的详细介绍，通过代码演示了如何创建和启动线程，以及如何进行线程睡眠和加入。掌握好这些概念和技巧可以帮助您编写更高效、更安全的多线程Java应用程序。</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>多个线程访问共享资源可能导致竞态条件（race condition）或死锁（deadlock）。互斥锁（mutex）是一种机制，用于确保在任何时候只有一个线程可以访问共享资源。Java中的互斥锁由synchronized关键字实现。在Java中，每个对象都有一个内部锁（intrinsic lock），也称为监视器锁（monitor lock）。每次只有一个线程可以拥有该锁，其他线程必须等待该线程释放锁。</p>
<ul>
<li><h4 id="互斥锁的基本概念"><a href="#互斥锁的基本概念" class="headerlink" title="互斥锁的基本概念"></a>互斥锁的基本概念</h4><ul>
<li>互斥锁是一种二进制信号量，在Java中用于保护临界区域（Critical Section），即多个线程可能同时访问和修改的共享数据或资源。</li>
<li>每个对象都有一个内部锁（Intrinsic Lock），可以使用<code>synchronized</code>关键字对其加锁。当某个线程获取了该对象的锁后，其他线程必须等待该线程释放锁才能继续执行。</li>
<li>当多个线程试图获取该对象的锁时，只有其中一个线程能够获得成功，其他线程则被阻塞。这种互斥性保证了同一时刻只有一个线程能进入临界区域，避免了数据竞争导致的错误结果。</li>
</ul>
</li>
<li><h4 id="互斥锁的使用方法"><a href="#互斥锁的使用方法" class="headerlink" title="互斥锁的使用方法"></a>互斥锁的使用方法</h4><p>在Java中，可以使用<code>synchronized</code>关键字来实现互斥锁。具体来说，有以下几种方式：</p>
<ol>
<li><h5 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h5><p>用<code>synchronized</code>修饰方法或代码块，对当前对象实例加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// critical section</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// critical section</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h5><p>用<code>synchronized</code>修饰静态方法或代码块，对当前类加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// critical section</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (ClassName.class) &#123;</span><br><span class="line">        <span class="comment">// critical section</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h4 id="互斥锁的局限性"><a href="#互斥锁的局限性" class="headerlink" title="互斥锁的局限性"></a>互斥锁的局限性</h4><p>尽管互斥锁可以保证线程之间的同步，但它也有以下局限性：</p>
<ul>
<li>粒度较大：如果多个临界区域使用同一个锁对象，则它们将被串行执行，从而降低了并发性能。</li>
<li>可重入性：同一线程可以多次获取同一个锁对象的锁，避免了死锁情况的发生。但是重入次数过多也会影响性能。</li>
<li>等待时间不确定：当某个线程持有锁对象进入无限循环等待资源的情况下，其他线程就会长时间阻塞，而没有办法得到通知或超时等机制。</li>
</ul>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是一个多线程程序中的常见问题，它发生在两个或多个线程互相等待对方释放资源的情况下。这可能导致程序停滞，无法继续执行。Java提供了一些机制来避免死锁，如使用tryLock方法而不是使用synchronized关键字，以及使用join方法来等待其他线程完成而不是等待锁。</p>
<p>以下是一个简单的死锁示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 1: Holding resource 1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>);&#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 1: Waiting for resource 2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 1: Holding resource 1 and 2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 2: Holding resource 2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>);&#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 2: Waiting for resource 1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 2: Holding resource 1 and 2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述代码中，有两个线程（thread1和thread2），它们都需要获取资源1和资源2才能继续执行。然而，它们都按不同的顺序获取这些资源，从而导致了死锁。</p>
<p>当thread1运行时，它获取了resource1并保持锁定状态。同时，thread2也开始运行，并获取了resource2并保持锁定状态。接着，thread1尝试获取resource2，但是它已经被thread2持有，因此它等待resource2被释放。同样的，thread2尝试获取resource1，但是它已经被thread1持有，所以它也等待resource1被释放。现在，两个线程都被阻塞，无法继续执行，从而导致了死锁。</p>
<p>为了避免死锁，我们应该确保所有线程以相同的顺序请求资源，并在持有一个资源的同时，不请求其他资源。如果确实需要请求其他资源，则可以在获得第一个资源后立即尝试获取其他资源，或者在超时时间内等待另一个线程释放资源。</p>
<p>要避免死锁，可以使用以下技术之一：</p>
<ol>
<li>避免循环等待：确保线程按照相同的顺序请求资源，这样就不会形成循环等待。</li>
<li>资源分配顺序：指定一个资源分配顺序，确保线程按照该顺序请求资源。</li>
<li>进程剥夺：如果一个线程持有资源并且另一个线程需要该资源，可以强制中断第一个线程，使其释放资源。</li>
<li>超时：在获取资源时设置超时时间，如果在规定时间内无法获得所需的资源，则放弃请求并释放已占用的资源。</li>
</ol>
<h3 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h3><p>Java的java.util.concurrent包中提供了一些并发集合类，可以在多线程环境下安全地使用。这些集合类包括ConcurrentHashMap、ConcurrentLinkedQueue和CopyOnWriteArrayList等。这些类使用锁和CAS（Compare-and-Swap）操作来实现线程安全性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(<span class="string">&quot;key&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池是管理线程的机制，它可以重复利用已经创建的线程，从而避免了线程创建和销毁的开销。Java中的线程池由Executor框架支持，它提供了一些预定义的线程池实现，如FixedThreadPool、CachedThreadPool和ScheduledThreadPool等。</p>
<p>Java线程池是一种用于高效地管理和复用线程的机制。当需要执行大量的异步任务时，可以使用线程池将这些任务分配给一组预先创建的线程，以提高性能和可靠性。</p>
<p>Java线程池包括以下几个组件：</p>
<ul>
<li><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>ThreadPoolExecutor是线程池的核心类，它负责管理线程池中的线程。通过配置ThreadPoolExecutor的参数，可以控制线程池的大小、队列容量、线程生命周期等。</p>
<p>ThreadPoolExecutor 是 Java 中线程池的实现之一。它提供了一个可重用的线程池，可以在请求到达时执行各种任务。</p>
<p>ThreadPoolExecutor 类有以下构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                           <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                           <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                           TimeUnit unit,</span></span><br><span class="line"><span class="params">                           BlockingQueue&lt;Runnable&gt; workQueue)</span></span><br></pre></td></tr></table></figure>

<p>这些参数的含义如下：</p>
<ul>
<li><code>corePoolSize</code>：线程池中保持的最小线程数；</li>
<li><code>maximumPoolSize</code>：线程池中允许的最大线程数；</li>
<li><code>keepAliveTime</code>：当线程池中数量超过 <code>corePoolSize</code>，多余的空闲线程存活的最长时间；</li>
<li><code>unit</code>：<code>keepAliveTime</code> 的时间单位；</li>
<li><code>workQueue</code>：任务队列；</li>
</ul>
<p>ThreadPoolExecutor 还提供了一些可选的参数，例如拒绝策略、线程工厂等。</p>
<p>ThreadPoolExecutor 根据一定的规则来执行任务，具体包括以下几步：</p>
<ol>
<li>如果当前线程数小于 corePoolSize，则创建新线程来执行任务。</li>
<li>如果当前线程数大于或等于 corePoolSize，则将任务加入到队列中（默认情况下是无界队列）。</li>
<li>如果队列已满并且当前线程数小于 maximumPoolSize，则创建新的线程来执行任务。</li>
<li>如果队列已满且当前线程数大于或等于 maximumPoolSize，则根据设置的拒绝策略来处理该任务。</li>
</ol>
<p>ThreadPoolExecutor 可以通过调用 <code>execute()</code> 方法来执行任务。该方法接受一个实现了 Runnable 接口的任务，将其提交到线程池中进行执行。需要注意的是，<code>execute()</code> 方法不会阻塞，它会立即返回，而任务会在后台异步执行。</p>
<p>除了 <code>execute()</code> 方法之外，ThreadPoolExecutor 还提供了一些其他的方法，例如 <code>submit()</code>、<code>invokeAll()</code>、<code>invokeAny()</code> 等，它们可以更方便地执行任务并获取任务的执行结果。</p>
<p>总的来说，ThreadPoolExecutor 是一个非常强大、灵活的线程池实现，可以满足各种场景下的需求。但需要注意的是，在使用时需要合理配置参数，避免线程数过多或过少，以及合理选择拒绝策略等。</p>
</li>
<li><h4 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h4><p>ThreadFactory是一个接口，用于创建新的线程。通过实现ThreadFactory接口，可以自定义线程的创建方式。</p>
</li>
<li><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>BlockingQueue是一个阻塞队列，用于存放等待执行的任务。当线程池中的所有线程都处于忙碌状态时，新的任务将被加入到队列中等待执行。</p>
</li>
<li><h4 id="RejectedExecutionHandler"><a href="#RejectedExecutionHandler" class="headerlink" title="RejectedExecutionHandler"></a>RejectedExecutionHandler</h4><p>RejectedExecutionHandler是一个接口，用于处理被拒绝的任务。当线程池的队列已满且无法继续添加任务时，RejectedExecutionHandler将会处理这些被拒绝的任务。</p>
</li>
<li><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>Java线程池的工作流程如下：</p>
<ol>
<li>创建ThreadPoolExecutor对象，并设置相关参数。</li>
<li>当有新任务提交时，如果线程池中的线程数量小于corePoolSize，则新建线程来执行任务。</li>
<li>如果线程池中的线程数量大于等于corePoolSize，但队列未满，则将任务加入到队列中等待执行。</li>
<li>如果队列已满且线程池中的线程数量小于maximumPoolSize，则新建线程来执行任务。</li>
<li>如果队列已满且线程池中的线程数量已经达到maximumPoolSize，则根据设置的RejectedExecutionHandler接口处理被拒绝的任务。</li>
</ol>
<p>Java线程池的优点包括：</p>
<ol>
<li>重用线程：避免了频繁创建和销毁线程的开销，提高了性能。</li>
<li>控制并发数：通过控制线程池中的线程数量和队列容量，可以避免系统因过多的并发任务而崩溃。</li>
<li>提供更好的响应性：当有新任务提交时，线程池中已存在的线程将立即开始执行任务，而不会像新建线程一样需要耗费额外时间。</li>
<li>提供更好的管理：可以通过ThreadPoolExecutor的相关参数来控制线程的生命周期、并发度等，方便系统的管理和调试。</li>
</ol>
</li>
</ul>
<p>Java 的多线程是一种并发编程的方式，允许在同一程序中同时执行多个线程，从而可以同时处理多个任务，提高程序的性能和效率。</p>
<p>类和接口</p>
<ol>
<li><p>Executor 接口：Executor 接口是 Java 提供的一个简化的线程池框架，用于管理和执行线程任务。通过 Executor 接口，可以将任务提交给线程池，由线程池来负责创建、管理和调度线程的执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">// 创建一个固定大小的线程池</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(); <span class="comment">// 创建一个实现了 Runnable 接口的任务</span></span><br><span class="line">executor.execute(task); <span class="comment">// 提交任务给线程池执行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>ThreadPoolExecutor 类：ThreadPoolExecutor 是 Executor 接口的实现类，它提供了更丰富的线程池配置和管理功能，例如线程池大小、线程池的拒绝策略、线程池的生命周期管理等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">5</span>, <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="number">10</span>, <span class="comment">// 最大线程数</span></span><br><span class="line">    <span class="number">60</span>, <span class="comment">// 空闲线程的存活时间</span></span><br><span class="line">    TimeUnit.SECONDS, <span class="comment">// 存活时间单位</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">100</span>), <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">// 拒绝策略</span></span><br><span class="line">);</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(); <span class="comment">// 创建一个实现了 Runnable 接口的任务</span></span><br><span class="line">executor.execute(task); <span class="comment">// 提交任务给线程池执行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>Lock 接口：Lock 接口提供了比传统的 synchronized 关键字更灵活和强大的线程同步方式。Lock 接口允许显式地获取和释放锁，从而可以更精细地控制线程的互斥访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">// 创建一个可重入锁</span></span><br><span class="line">lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行临界区代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>Condition 接口：Condition 接口可以与 Lock 接口一起使用，提供了更灵活和高级的线程通信方式。通过 Condition 接口，可以实现线程间的等待和通知机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">// 创建一个可重入锁</span></span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition(); <span class="comment">// 创建一个条件变量</span></span><br><span class="line">lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!conditionMet()) &#123;</span><br><span class="line">        condition.await(); <span class="comment">// 等待条件满足</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">知无涯</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/29/java%E8%BF%9B%E9%98%B6/">http://example.com/2023/03/29/java%E8%BF%9B%E9%98%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">YunisTo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/31/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8ASQL%E8%AF%AD%E5%8F%A5/" title="MySQL数据库及SQL语句"><img class="cover" src="https://cdn.jsdelivr.net/gh/Yunis3056/blogimage@main/img/2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL数据库及SQL语句</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="面向对象"><img class="cover" src="https://cdn.jsdelivr.net/gh/Yunis3056/blogimage@main/img/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">面向对象</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Yunis3056/blogimage@main/img/08.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">知无涯</div><div class="author-info__description">永远善良，永远来日方长</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Yunis3056"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Yunis3056" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:lyns3056@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#javaSE%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">javaSE进阶学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB"><span class="toc-number">1.2.1.</span> <span class="toc-text">String类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">创建字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">字符串方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">字符串不可变性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">字符串常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math%E7%B1%BB"><span class="toc-number">1.2.2.</span> <span class="toc-text">Math类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">基本数学运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">三角函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%95%B0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">对数函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">随机数函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Date%E7%B1%BB"><span class="toc-number">1.2.3.</span> <span class="toc-text">Date类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Calendar%E7%B1%BB"><span class="toc-number">1.2.4.</span> <span class="toc-text">Calendar类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BACalendar%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">创建Calendar实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E4%BF%A1%E6%81%AF"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">获取日期和时间信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E4%BF%A1%E6%81%AF"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">修改日期和时间信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%9A%84%E5%8A%A0%E5%87%8F"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">日期和时间的加减</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">日期和时间的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4"><span class="toc-number">1.2.4.6.</span> <span class="toc-text">格式化日期和时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SimpleDateFormat%E7%B1%BB"><span class="toc-number">1.2.5.</span> <span class="toc-text">SimpleDateFormat类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%BA%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">解析字符串为日期对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">将日期对象格式化为字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AD%97%E6%AF%8D%E5%90%AB%E4%B9%89"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">模式字母含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">线程安全问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileInputStream%E5%92%8CFileOutputStream%E7%B1%BB"><span class="toc-number">1.2.6.</span> <span class="toc-text">FileInputStream和FileOutputStream类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FileInputStream"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">FileInputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.6.1.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.6.1.2.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.2.6.1.3.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileOutputStream"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">FileOutputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="toc-number">1.2.6.2.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-1"><span class="toc-number">1.2.6.2.2.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-1"><span class="toc-number">1.2.6.2.3.</span> <span class="toc-text">实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InputStream%E5%92%8COutputStream%E7%B1%BB"><span class="toc-number">1.2.7.</span> <span class="toc-text">InputStream和OutputStream类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InputStream%E7%B1%BB"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">InputStream类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OutputStream%E7%B1%BB"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">OutputStream类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InputStream%E5%92%8COutputStream%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.7.3.</span> <span class="toc-text">InputStream和OutputStream的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reader%E5%92%8CWriter%E7%B1%BB"><span class="toc-number">1.2.8.</span> <span class="toc-text">Reader和Writer类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Reader"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">Reader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Writer"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">Writer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reader%E5%92%8CWriter%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">Reader和Writer的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Random%E7%B1%BB-%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">1.2.9.</span> <span class="toc-text">Random类(随机数)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder%E7%B1%BB"><span class="toc-number">1.2.10.</span> <span class="toc-text">StringBuilder类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuilder%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9%E5%8C%85%E6%8B%AC"><span class="toc-number">1.2.10.1.</span> <span class="toc-text">StringBuilder类的主要特点包括</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-number">1.2.10.2.</span> <span class="toc-text">代码演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuilder%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.10.3.</span> <span class="toc-text">StringBuilder常用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">1.3.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-number">1.3.1.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedList"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">LinkedList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-number">1.3.2.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeSet"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">TreeSet</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">1.3.3.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">TreeMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue"><span class="toc-number">1.3.4.</span> <span class="toc-text">Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PriorityQueue"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">PriorityQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayDeque"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">ArrayDeque</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFThread%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">继承Thread类创建线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">实现Runnable接口创建线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9D%A1%E7%9C%A0"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">线程睡眠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E5%85%A5%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">加入线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">线程状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">1.4.2.</span> <span class="toc-text">互斥锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">互斥锁的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">互斥锁的使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E9%94%81"><span class="toc-number">1.4.2.2.1.</span> <span class="toc-text">对象锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E9%94%81"><span class="toc-number">1.4.2.2.2.</span> <span class="toc-text">类锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">互斥锁的局限性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.4.3.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88"><span class="toc-number">1.4.4.</span> <span class="toc-text">并发集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.4.5.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadPoolExecutor"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadFactory"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">ThreadFactory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BlockingQueue"><span class="toc-number">1.4.5.3.</span> <span class="toc-text">BlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RejectedExecutionHandler"><span class="toc-number">1.4.5.4.</span> <span class="toc-text">RejectedExecutionHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.5.5.</span> <span class="toc-text">工作流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">网络编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JUnit"><span class="toc-number">1.6.</span> <span class="toc-text">JUnit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.7.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.8.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-number">1.9.</span> <span class="toc-text">反射机制</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/12/%E9%97%AE%E9%A2%98%E5%BD%92%E7%BA%B3/" title="问题归纳"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="问题归纳"/></a><div class="content"><a class="title" href="/2023/04/12/%E9%97%AE%E9%A2%98%E5%BD%92%E7%BA%B3/" title="问题归纳">问题归纳</a><time datetime="2023-04-12T06:51:29.000Z" title="发表于 2023-04-12 14:51:29">2023-04-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/02/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题"><img src="https://cdn.jsdelivr.net/gh/Yunis3056/blogimage@main/img/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试题"/></a><div class="content"><a class="title" href="/2023/04/02/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题">面试题</a><time datetime="2023-04-02T10:01:18.000Z" title="发表于 2023-04-02 18:01:18">2023-04-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/31/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8ASQL%E8%AF%AD%E5%8F%A5/" title="MySQL数据库及SQL语句"><img src="https://cdn.jsdelivr.net/gh/Yunis3056/blogimage@main/img/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL数据库及SQL语句"/></a><div class="content"><a class="title" href="/2023/03/31/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8ASQL%E8%AF%AD%E5%8F%A5/" title="MySQL数据库及SQL语句">MySQL数据库及SQL语句</a><time datetime="2023-03-30T16:07:34.000Z" title="发表于 2023-03-31 00:07:34">2023-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/29/java%E8%BF%9B%E9%98%B6/" title="Java进阶"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java进阶"/></a><div class="content"><a class="title" href="/2023/03/29/java%E8%BF%9B%E9%98%B6/" title="Java进阶">Java进阶</a><time datetime="2023-03-29T04:20:16.000Z" title="发表于 2023-03-29 12:20:16">2023-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="面向对象"><img src="https://cdn.jsdelivr.net/gh/Yunis3056/blogimage@main/img/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面向对象"/></a><div class="content"><a class="title" href="/2023/03/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="面向对象">面向对象</a><time datetime="2023-03-26T12:25:05.000Z" title="发表于 2023-03-26 20:25:05">2023-03-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By 知无涯</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="8260486260" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>